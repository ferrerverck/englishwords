package com.words.model.mysqlmodel;

import com.words.controller.utils.DateTimeUtils;
import com.words.main.EnglishWords;
import com.words.model.filemodel.IterationLog;
import com.words.model.filemodel.FutureWordManager;
import com.words.model.filemodel.RepeatWords;
import com.words.model.filemodel.WordDefinitions;
import com.words.model.filemodel.WordManager;
import com.words.model.filemodel.WordStats;
import java.io.BufferedWriter;
import java.io.IOException;
import java.io.Writer;
import java.nio.charset.StandardCharsets;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.time.LocalDate;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;

public class MysqlModelToFileModel {
    
    private final Path currentDir;
    private final Connection con;
    
    public static void main(String[] args) throws Exception {
        MysqlModelToFileModel backup = new MysqlModelToFileModel(
            EnglishWords.PROJECT_DIRECTORY);
        
        backup.backup();
    }
    
    public MysqlModelToFileModel(Path projectDir, Connection con) throws Exception {
        Path backupDir = projectDir.resolve("backup");
        if (Files.notExists(backupDir)) Files.createDirectories(backupDir);
        
        LocalDate now = LocalDate.now();
        currentDir = backupDir.resolve(now.toString());
        
        if (Files.exists(currentDir)) {
            // then delete
            Files.walkFileTree(currentDir, new SimpleFileVisitor<Path>() {
                
                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)
                    throws IOException {
                    Files.delete(file);
                    return FileVisitResult.CONTINUE;
                }
                
                @Override
                public FileVisitResult postVisitDirectory(Path dir, IOException exc)
                    throws IOException {
                    Files.delete(dir);
                    return FileVisitResult.CONTINUE;
                }
            });
        }
        
        Files.createDirectory(currentDir);
        
        this.con = con;
    }
    
    private MysqlModelToFileModel(Path projectDir) throws Exception {
        this(projectDir, createConnection());
    }
    
    private static Connection createConnection() throws Exception {
        return new MysqlModel(EnglishWords.TITLE).getConnection();
    }
    
    public void backup() {
        backupIterations();
        backupRepeatWords();
        backupWordsAndDefinitions();
        backupFutureWords();
    }
    
    private void backupIterations() {
        String query = "SELECT local_date, iterations FROM daily_iterations";
        
        Properties props = new Properties();
        
        try (PreparedStatement ps = con.prepareStatement(query)) {
            ResultSet rs = ps.executeQuery();
            int i = 0;
            while (rs.next()) {
                LocalDate ld = rs.getDate("local_date").toLocalDate();
                String key = DateTimeUtils.localDateToString(ld);
                int iterations = rs.getInt("iterations");
                props.put(key, "" + iterations);
                i++;
            }
            if (props.size() > 0) {
                props.store(Files.newBufferedWriter(currentDir.resolve(IterationLog.LOG_FILE_NAME)),
                    "Autogenerated");
                System.out.println("Backed up " + i + " iterations");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private void backupRepeatWords() {
        String query = "SELECT w.word, rw.date_added FROM words AS w JOIN " +
            "repeat_words AS rw ON w.word_id = rw.word_id";
        
        Properties props = new Properties();
        
        try (PreparedStatement ps = con.prepareStatement(query)) {
            ResultSet rs = ps.executeQuery();
            int i = 0;
            while (rs.next()) {
                String word = rs.getString("w.word");
                LocalDate ld = rs.getDate("rw.date_added").toLocalDate();
                String key = DateTimeUtils.localDateToString(ld);
                
                StringBuilder sb = new StringBuilder(props.getProperty(key, ""));
                if (sb.length() != 0) sb.append(RepeatWords.DELIMITER);
                sb.append(word);
                
                props.put(key, sb.toString());
                
                i++;
            }
            props.store(Files.newBufferedWriter(
                currentDir.resolve(RepeatWords.FILE_NAME)),
                "Autogenerated");
            System.out.println("Backuped " + i + " repeat words");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private void backupWordsAndDefinitions() {
        String query = "SELECT word, translation, synonyms, definition, " +
            "bundle_date, complexity_name, times_picked, last_picked_timestamp " +
            "FROM words " +
            "JOIN bundles ON words.bundle_id = bundles.bundle_id " +
            "JOIN complexities ON words.complexity_id = complexities.complexity_id ";
        
        Properties defProps = new Properties();
        Properties statsProps = new Properties();
        
        int i = 0;
        try (PreparedStatement ps = con.prepareStatement(query)) {
            ResultSet rs = ps.executeQuery();
            String delimiter = WordManager.DELIMITER + WordManager.DELIMITER;
            
            try (Writer out = Files.newBufferedWriter(
                currentDir.resolve(WordManager.FILE_NAME),
                StandardCharsets.UTF_8)) {
                Map<LocalDate, StringBuilder> formattedWordMap = new HashMap<>();
                while (rs.next()) {
                    String word = rs.getString("word");
                    String translation = rs.getString("translation");
                    String synonyms = rs.getString("synonyms");
                    LocalDate date = rs.getDate("bundle_date").toLocalDate();
                    
                    int timesPicked = rs.getInt("times_picked");
                    long lastPickedTimestamp = rs.getLong("last_picked_timestamp");
                    String complexityName = rs.getString("complexity_name");
                    
                    StringBuilder line = formattedWordMap.getOrDefault(
                        date, new StringBuilder());
                    line.append(word).append(delimiter).append(translation);
                    if (!synonyms.isEmpty())
                        line.append(delimiter).append(synonyms);
                    line.append(System.lineSeparator());
                    formattedWordMap.put(date, line);
                    
                    String definition = rs.getString("definition");
                    
                    if (definition != null) defProps.setProperty(word, definition);
                    
                    String statsDelimiter = WordStats.DELIMITER;
                    statsProps.setProperty(word, timesPicked + statsDelimiter +
                        lastPickedTimestamp + statsDelimiter + complexityName);
                    
                    i++;
                }
                
                
                formattedWordMap.forEach((date, sb) -> {
                    try {
                        out.append(WordManager.BUNDLE_PREFIX)
                            .append(DateTimeUtils.localDateToString(date))
                            .append(System.lineSeparator()).append(sb);
                    } catch (IOException ex) { }
                });
                
                out.flush();
                
            }
            
            defProps.store(Files.newBufferedWriter(
                currentDir.resolve(WordDefinitions.FILE_NAME)),
                "Autogenerated");
            
            statsProps.store(Files.newBufferedWriter(
                currentDir.resolve(WordStats.FILE_NAME)),
                "Autogenerated");
            
            System.out.println("Backuped " + i + " words");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    private void backupFutureWords() {
        String query = "SELECT future_word, priority FROM future_words";
        
        String delimiter =
            FutureWordManager.DELIMITER + FutureWordManager.DELIMITER;
        
        try (PreparedStatement ps = con.prepareStatement(query)) {
            ResultSet rs = ps.executeQuery();
            
            try (BufferedWriter out =
                Files.newBufferedWriter(
                    currentDir.resolve(FutureWordManager.FILE_NAME))) {
                int i = 0;
                while (rs.next()) {
                    String futureWord = rs.getString("future_word");
                    int priority = rs.getInt("priority");
                    
                    out.append(futureWord).append(delimiter).append("" + priority);
                    out.newLine();
                    
                    i++;
                }
                
                out.flush();
                
                System.out.println("Saved " + i + " future words");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
